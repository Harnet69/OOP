ООП
--------
Класс: 
class MyClass{
	public $name = 'John'; // свойство класса
	public $age;
	public function SayHello($who){// описание метода 
		echo 'Hello, '.$this->name; //обращение к св-ву
		$this->DrawBr();// обращение к методу
	}
	function DrawBr(){
		echo '<br>';
	}
}
$myObj = new MyClass();  //инициализация класса(создание объекта,экземпляра класса)
echo $myObj->name; //доступ к св-вам класса
$myObj->age = 25; // изменение значения св-вам
$myObj->SayHello('John');// вызов метода

Псевдоконстанты: 
__METHOD__ -вернет имя метода
__CLASS__-вернет имя класса

Модификаторы доступа к свойствам и методам класса: 
public(видимость глобальная, общедоступен),
protected(видимость из наследника и из родителя),
private(видимость только в этом классе)
<свойство или метод> - у защищённого метода (свойства) имя начинается с подчёркивания

function __construct (){} - конструктор (функция), который запускается при создании объекта класса
function __dectruct(){} - деструктор, который запускается при удалении объекта
function __clone(){} - клонирование объекта
$newobj = clone $obj; - клонирование объекта (конструктор не запускается)

Наследование class Child extends Father{}
Метод в классе-наследнике можно перегрузить.
Обращение к родительскому классу : parent:: <название родительского метода>

Обработка исключений:
<?
try {
	$a = 1;
	$b = 0;	
		if ($b ==0){
			throw new Exception ("на ноль делить нельзя!<br>");
			}
		$c = $a/$b;
	}catch (Exception $e){
		echo "Ошибка : ".$e->GetMessage()."<br>";
		echo "В строке : ".$e->GetLine()."<br>";
		echo "В файле : ".$e->GetFile()."<br>";
	}
echo "А код продолжается";
?> 
Try/catch обязательно размещается в классе внутри метода
Блоков Try может быть несколько, и все они отлавливаются в одном catch. В Try может быть несколько if, как только срабатывает первый, остальные не перебираются
Класс Exception можно наследовать, но обязательно перегружать его конструктор (совместимость с будущими PHP).
function __construct($<что приходит>){
			parent:: __construct($<что приходит>);
		}
		
Перебор свойств объекта ("снаружи" видит только свойства public):
class Human{
	public $name;
	public $age;
	function __construct($name, $age){
		$name = $this->name;
		$name = $this->age;
	}
}
$human1 = new Human("John", 55);
	foreach ($human1 as $name=>$value){
		echo $name."  :  ".$value."<br>";
	}
	
Константы класса 
const <имя константы> = <значение константы> - задать константу внутри класса
self::<имя константы> - вызов константы класса в методе
$<имя экземпляра класса>::<имя константы> - обращение к константе класса из-вне 
				ИЛИ
<имя класса>::<имя константы> - обращение к константе класса из-вне

Абстрактные классы и методы 
	abstract class <имя класса>{} - класс от которого нельзя создать обьект напрямую, его можно только наследовать(может не иметь абстрактных методов)
	abstract function() - абстрактный метод (бывает только в абстрактном классе), без переопределения предка наследником - не работает

Интерфейс - абстрактный класс, имющий только абстрактные методы. Один интерфейс - много реализаций
	interface <имя>{
		function <имя>(); // метод
	}
	class <имя> implements <имя интерфейса>, <имя интерфейса>,... (наследуемые интерфейсы не должны содержать одноименные методы)  
Наследовать можно только ОДНОМУ классу, но подключить( implements ) МНОГО интерфейсов.

	Финальные методы - невозможно перегрузить метод(применяется, например если описание метода ещё не готово) final function <имя>();
	Финальные классы - невозможно наследовать класс final class
 
	Статическoe свойство static - доступ к свойству: 
-изнутри класса только через self::$name
-из глобальной области видимости <имя класса>::$<имя свойства>
Пример - счетчик.	
	Статический метод static - доступ аналогичен. Используют, чтобы к ним обращаться, не создавая лишнего экземпляра класса.

Динамические статические вызовы с РНР 5,3 :
Можно имя класса, статический метод иметь в переменной и к ним обращаться через переменную.
$class = "User";
$method = "getInfo";
$class::$method();
	
instanceOf - проверка принадлежности к цепочке наследования.
Возвращает true-false
if ($user0 instanceOf User){
echo 'Admin is User';
}
тоже самое что и is_a
if(is_a($user0, User)){
echo 'Admin is User';
}

Автоматическая загрузка объектов:
function __autoload($class_name){
	include $class_name .'.php';}
Каждый класс в отдельном файле(имя класса == имя файла)

Доступ к невидимым свойствам.
Поля и свойства - свойство это интерфейс доступа к полю. Поле всегда private
Защита с помощью сеттеров и геттеров. Продолжение работы кода даже при вызове несуществующего метода или обращении к приватному или невидимому свойству.
<?
class User{
	private $_data = array();
	
	public function __set($name, $value){
		$this->_data[$name] = $value;
	}
		
	public function __get($name){
		if(array_key_exists ($name, $this->data)){
			return $this->data[$name];
		}
	}
	//доступ к невидимому методу
	public function __call($name, $a){
		echo $name.' do not work '. implode(', ',$a);
	}
	/* значение $name регистрозависимо!*.
	public static function __callStatic($name, $a){
		echo "Вызов метода '$name'". implode(', ', $a);
	}
	*/
	private function bebe(){
		echo 'memememe';
	}
	
	public function __toString(){
		return "A vot figvam!";
	}
}
$object = new User;
$object->name = "superpuper";
echo '<h1>'.$object->name.'</h1>';
$object->foo(1,2);
echo '<br>blabla<hr>';
$object->bebe();
echo '<br>blabla<hr>';
echo $object;
?>
И еще хороший пример(подобие True OOP) :
<?
class Person{
	private $_name;
	private $_age;
	function __set($n, $v){
		switch($n){
			case 'name' : $this->_name = $v;break:
			case 'age' : $this->_age = $v;break;
			default: throw new Exception('ERROR')
		}
	}
	function __get($n){
		switch($n){
			case 'name' : return $this->_name;break:
			case 'age' : return $this->_age;break;
			default: throw new Exception('ERROR')
		}
	}
}
?>

РНР не поддерживает перегрузку функций!!!

Преобразование объекта в строку.
	function __toString(){
		return "A vot figvam!";
	}
тогда в случае $one = new Person;
echo $one; выведется A vot figvam!

Объект как функция(РНР 5.4)
сlass Test Class{
	public function __invoke($var){
		return $var * $var;
	}
}
$obj = new Testclass();
echo $obj(5);

Контроль типа (type-hint)
function foo(ClassA $obj){
/*Ожидается только экземпляр класса ClassA*/
}
function foo(callable $x){///сюда передается что-то вызываемое
	return $x();
}
варианты что можно передать:
-имя функции
-foo(['Classname', 'staticMethodname']);//массив, где имя класса и имя метода
foo($object, 'methodName');//объект и имя метода
foo($invokableObject);///тот объект который инвотится

Сериализация
если объект просто сериализовать, то он будет пустым
class User{
	private $login,$password;
	function __construct($login,$password){
		$this->login = $login;
		$this->password = $password;
		$this->getUser();
	}
	private function getUser(){}
	public function __sleep(){//должен возвращать массив имен в виде строк
		return array('login', 'password');
	}
	public function __wakeup(){//это надо для вызова getUser, без вызова конструктора
		$this->getUser();
	}
}

Traits(РНР 5.5) Типажи
это как класс, но от них нельзя создать экземпляр, их можно только подключать.
trait Hello{
	function hello(){return 'Hello';}
}
trait User{
	function user($name){return $name;}
}
class Welcome{
	use Hello, User;
}
$obj = new Welcome();
echo $obj->hello(), ' ', $obj->user('John');

Наследование (трэйты можно вкладывать в трэйты)
trait Hello{
	function hello(){return 'Hello';}
}
trait User{
	function user($name){return $name;}
}
trait Greeting{
	use Hello, User;
	function sayHello($name){
		echo $this->hello(), $this->user($name);
	}
}
class Welcome {use Greeting;}
(new Welcome())->sayhello('John');

Изменение модификаторов только в трэйтах!!
trait Hello{
	private function sayHello($name){
		return 'Hello', $name;
	}
}
class Welcome {
	use Hello{sayHello as public};
}
$obj = new Welcome();
echo $obj->sayHello('John');

Разрешение конфликтов
trait Hello{
	private function sayHello(){return 'Hello';}
}
trait User{
	public function sayHello($name){return $name;}
}
class Welcome {
	use User, Hello{
		Hello::sayHello as public word;//используй метод как паблик
		User::sayHello insteadof Hello;//используй под именем сэйхеллоу юзеровский вместо хеллоу
		}
}
$obj = new Welcome();
echo $obj->word(), ' ', $obj->sayHello('John');
ООП
--------
Класс: 
class MyClass{
	public $name = 'John'; // свойство класса
	public $age;
	public function SayHello($who){// описание метода 
		echo 'Hello, '.$this->name; //обращение к св-ву
		$this->DrawBr();// обращение к методу
	}
	function DrawBr(){
		echo '<br>';
	}
}
$myObj = new MyClass();  //инициализация класса(создание объекта,экземпляра класса)
echo $myObj->name; //доступ к св-вам класса
$myObj->age = 25; // изменение значения св-вам
$myObj->SayHello('John');// вызов метода

Псевдоконстанты: 
__METHOD__ -вернет имя метода
__CLASS__-вернет имя класса

Модификаторы доступа к свойствам и методам класса: 
public(видимость глобальная, общедоступен),
protected(видимость из наследника и из родителя),
private(видимость только в этом классе)
<свойство или метод> - у защищённого метода (свойства) имя начинается с подчёркивания

function __construct (){} - конструктор (функция), который запускается при создании объекта класса
function __dectruct(){} - деструктор, который запускается при удалении объекта
function __clone(){} - клонирование объекта
$newobj = clone $obj; - клонирование объекта (конструктор не запускается)

Наследование class Child extends Father{}
Метод в классе-наследнике можно перегрузить.
Обращение к родительскому классу : parent:: <название родительского метода>

Обработка исключений:
<?
try {
	$a = 1;
	$b = 0;	
		if ($b ==0){
			throw new Exception ("на ноль делить нельзя!<br>");
			}
		$c = $a/$b;
	}catch (Exception $e){
		echo "Ошибка : ".$e->GetMessage()."<br>";
		echo "В строке : ".$e->GetLine()."<br>";
		echo "В файле : ".$e->GetFile()."<br>";
	}
echo "А код продолжается";
?> 
Try/catch обязательно размещается в классе внутри метода
Блоков Try может быть несколько, и все они отлавливаются в одном catch. В Try может быть несколько if, как только срабатывает первый, остальные не перебираются
Класс Exception можно наследовать, но обязательно перегружать его конструктор (совместимость с будущими PHP).
function __construct($<что приходит>){
			parent:: __construct($<что приходит>);
		}
		
Перебор свойств объекта ("снаружи" видит только свойства public):
class Human{
	public $name;
	public $age;
	function __construct($name, $age){
		$name = $this->name;
		$name = $this->age;
	}
}
$human1 = new Human("John", 55);
	foreach ($human1 as $name=>$value){
		echo $name."  :  ".$value."<br>";
	}
	
Константы класса 
const <имя константы> = <значение константы> - задать константу внутри класса
self::<имя константы> - вызов константы класса в методе
$<имя экземпляра класса>::<имя константы> - обращение к константе класса из-вне 
				ИЛИ
<имя класса>::<имя константы> - обращение к константе класса из-вне

Абстрактные классы и методы 
	abstract class <имя класса>{} - класс от которого нельзя создать обьект напрямую, его можно только наследовать(может не иметь абстрактных методов)
	abstract function() - абстрактный метод (бывает только в абстрактном классе), без переопределения предка наследником - не работает

Интерфейс - абстрактный класс, имющий только абстрактные методы. Один интерфейс - много реализаций
	interface <имя>{
		function <имя>(); // метод
	}
	class <имя> implements <имя интерфейса>, <имя интерфейса>,... (наследуемые интерфейсы не должны содержать одноименные методы)  
Наследовать можно только ОДНОМУ классу, но подключить( implements ) МНОГО интерфейсов.

Финальные методы - невозможно перегрузить метод(применяется, например если описание метода ещё не готово) final function <имя>();
Финальные классы - невозможно наследовать класс final class
  

		Статические свойства и методы - видны с глобаной области видимости даже когда код отработал